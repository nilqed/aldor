<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Data structures</TITLE>
<META NAME="description" CONTENT="Data structures">
<META NAME="keywords" CONTENT="html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="html.css">

<LINK REL="next" HREF="node9.html">
<LINK REL="previous" HREF="node7.html">
<LINK REL="up" HREF="node6.html">
<LINK REL="next" HREF="node9.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html548"
  HREF="node9.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html542"
  HREF="node6.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html536"
  HREF="node7.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html544"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html546"
  HREF="node315.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html549"
  HREF="node9.html">Input/Output</A>
<B> Up:</B> <A NAME="tex2html543"
  HREF="node6.html">User Guide</A>
<B> Previous:</B> <A NAME="tex2html537"
  HREF="node7.html">Arithmetic</A>
 &nbsp; <B>  <A NAME="tex2html545"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A NAME="tex2html547"
  HREF="node315.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00032000000000000000">
Data structures</A>
</H2>
<TT>libaldor</TT>  provides both linear data structures (e.g.&nbsp;arrays and lists)
and non-linear ones (e.g.&nbsp;hash tables). The category hierarchy for
data structures is shown in Figure&nbsp;<A HREF="#fig:data">2</A>.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:data"></A><A NAME="324"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
The <TT>libaldor</TT>&nbsp;category hierarchy for data structures</CAPTION>
<TR><TD><IMG
 WIDTH="1194" HEIGHT="850" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="\includegraphics{sallidata}"></TD></TR>
</TABLE>
</DIV>

<P>
<TT>libaldor</TT>  provides some standard linear
data structures having very similar functionalities:
<A HREF="node211.html#List"><TT>List</TT></A>&nbsp;<TT>T</TT> and <A HREF="node182.html#CheckingList"><TT>CheckingList</TT></A>&nbsp;<TT>T</TT>
both provide linked lists
whose entries are of type <TT>T</TT>, while
<A HREF="node163.html#Array"><TT>Array</TT></A>&nbsp;<TT>T</TT> and <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A>&nbsp;<TT>T</TT> both provide
arrays whose entries are of type <TT>T</TT>.
Lower-level linear data structures are <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A>&nbsp;<TT>T</TT>
and <A HREF="node229.html#PackedPrimitiveArray"><TT>PackedPrimitiveArray</TT></A>&nbsp;<TT>T</TT>,
which provide simpler arrays whose entries are of type <TT>T</TT>.
All of those data structures can be created by explicitly listing a
finite number of elements, for example
<BR>
<DIV ALIGN="CENTER">
<TT>l:<A HREF="node211.html#List"><TT>List</TT></A> <A HREF="node257.html#String"><TT>String</TT></A> := ["hello", "world"] </TT></DIV>
or by bracketing a generator, for example
<BR>
<DIV ALIGN="CENTER">
 <TT>a:<A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A> <A HREF="node82.html#MachineInteger"><TT>MachineInteger</TT></A> :=
[n for n in 1..100 | odd?&nbsp;n]</TT>.</DIV>
In addition, the function <A HREF="node193.html#FiniteLinearStructureType:new"><TT>new</TT></A>
also allows structures to be created, and the constant
<A HREF="node192.html#FiniteLinearStructureType:empty"><TT>empty</TT></A>
returns an empty structure. The individual elements can
be accessed via <TT>s.n</TT> where <TT>s</TT> is a data structure and
<TT>n</TT> an index. The indexing scheme and the bound-checking scheme
both depend on the structure:
<A HREF="node211.html#List"><TT>List</TT></A> and <A HREF="node182.html#CheckingList"><TT>CheckingList</TT></A> are 1-indexed, while
<A HREF="node163.html#Array"><TT>Array</TT></A>, <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A>, <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A>
and <A HREF="node229.html#PackedPrimitiveArray"><TT>PackedPrimitiveArray</TT></A> are 0-indexed.
If you need to know the indexing scheme at runtime,
or want to write index-independent code, the <TT>firstIndex</TT> constant
returns the index of the first element of a structure.

<P>
The general form for iterating efficiently over a
<A HREF="node178.html#BoundedFiniteLinearStructureType"><TT>BoundedFiniteLinearStructureType</TT></A> is
<BR>
<DIV ALIGN="CENTER">
 <TT>for</TT> <EM>variable</EM> <TT>in</TT> <EM>structure</EM>
| <EM>condition</EM> <TT>repeat { ...&nbsp;}</TT> </DIV>
where ``| <EM>condition</EM>'' is optional. This is available
for all high-level linear data structures,
but not for those of category <A HREF="node231.html#PrimitiveArrayType"><TT>PrimitiveArrayType</TT></A>.

<P>
There are classical tradeoffs between the various array types:
the only difference between <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A> and <A HREF="node163.html#Array"><TT>Array</TT></A>
is that <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A> checks whether the index is within the range
of the array, while <A HREF="node163.html#Array"><TT>Array</TT></A> does not. Similarly,
<A HREF="node182.html#CheckingList"><TT>CheckingList</TT></A> checks whether a list is empty before calling
<A HREF="node220.html#ListType:first"><TT>first</TT></A> and <A HREF="node222.html#ListType:rest"><TT>rest</TT></A>, while <A HREF="node211.html#List"><TT>List</TT></A>
does not.
Since both pairs of types offer the same exports,
you can use one during the development
and testing phase, and then switch to the other for releasing your code.
An advantage of the lower-level arrays of category&nbsp;<A HREF="node231.html#PrimitiveArrayType"><TT>PrimitiveArrayType</TT></A>
is that they are compatible with C pointers and
generate more efficient code when accessing their elements.
In order to benefit from the advantages of all those types,
<TT>libaldor</TT>  provides the <A HREF="node169.html#ArrayType:data"><TT>data</TT></A> function,
which returns the data of an <A HREF="node163.html#Array"><TT>Array</TT></A> or <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A>
as a <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A> without copying or allocating memory.
It is thus possible to use <A HREF="node163.html#Array"><TT>Array</TT></A> or <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A>
in your code, making sure to
apply <A HREF="node169.html#ArrayType:data"><TT>data</TT></A> to it before accessing elements in a loop.
For example, the following function efficiently computes the sum
of all the elements with even indices of an array of machine integers:
<PRE>
evenSum(a:Array MachineInteger):MachineInteger == {
    import from MachineInteger;               -- for the index i
    import from PrimitiveArray MachineInteger;-- for accessing the elements of p
    p := data a;                              -- for efficiency (optimized code)
    sum:MachineInteger := 0;
    for i in 0..#a by 2 repeat sum := sum + p.i;
    sum;
}
</PRE>

Conversely, the function <A HREF="node167.html#ArrayType:array"><TT>array</TT></A>
creates an <A HREF="node163.html#Array"><TT>Array</TT></A> or <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A>
from a <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A> without copying.
Note that the
<A HREF="node176.html#BoundedFiniteDataStructureType:generator"><TT>generator</TT></A> functions
in <A HREF="node163.html#Array"><TT>Array</TT></A> and <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A> use the <A HREF="node169.html#ArrayType:data"><TT>data</TT></A>
function, so iterating an <A HREF="node163.html#Array"><TT>Array</TT></A> or <A HREF="node181.html#CheckingArray"><TT>CheckingArray</TT></A> <TT>a</TT> via
<BR>
<DIV ALIGN="CENTER">
<TT>for x in a repeat { ...&nbsp;}</TT></DIV>
is as efficient as using a <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A>.
Note that the debug version<A NAME="tex2html6"
  HREF="footnode.html#foot5463"><SUP>2</SUP></A> of <TT>libaldor</TT>  performs bound checking on
accesses into all types of arrays, including <A HREF="node257.html#String"><TT>String</TT></A> and
all the low-level array types.

<P>
Since <A HREF="node257.html#String"><TT>String</TT></A> has the category
<A HREF="node166.html#ArrayType"><TT>ArrayType</TT></A>&nbsp;<A HREF="node123.html#Character"><TT>Character</TT></A>,
all the array functionalities
are also applicable to strings. For example,
<BR>
<DIV ALIGN="CENTER">
<TT>for c in "hello" repeat { ...&nbsp;}</TT></DIV>
assigns successively the characters 'h', 'e', 'l', 'l' and 'o' to <TT>c</TT>,
and strings can be created from <A HREF="node293.html#Generator"><TT>Generator</TT></A>&nbsp;<A HREF="node123.html#Character"><TT>Character</TT></A>.
Note that <A HREF="node257.html#String"><TT>String</TT></A> and <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A> <A HREF="node123.html#Character"><TT>Character</TT></A>
are not interchangeable, since the former is packed and not the latter.
<A HREF="node257.html#String"><TT>String</TT></A> is however interchangeable with
<A HREF="node229.html#PackedPrimitiveArray"><TT>PackedPrimitiveArray</TT></A>&nbsp;<A HREF="node123.html#Character"><TT>Character</TT></A>.
Similarly, chunks of memory viewed as byte arrays are provided by
either one of <A HREF="node237.html#PrimitiveMemoryBlock"><TT>PrimitiveMemoryBlock</TT></A>,
<A HREF="node228.html#MemoryBlock"><TT>MemoryBlock</TT></A> or <A HREF="node183.html#CheckingMemoryBlock"><TT>CheckingMemoryBlock</TT></A>. Those types
are to be used for buffers rather than <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A>&nbsp;<A HREF="node119.html#Byte"><TT>Byte</TT></A>,
which is not interchangeable with <A HREF="node237.html#PrimitiveMemoryBlock"><TT>PrimitiveMemoryBlock</TT></A>.

<P>
For types whose elements are not word-size, such as <A HREF="node119.html#Byte"><TT>Byte</TT></A>,
<A HREF="node123.html#Character"><TT>Character</TT></A>, <A HREF="node103.html#SingleFloat"><TT>SingleFloat</TT></A> and <A HREF="node42.html#DoubleFloat"><TT>DoubleFloat</TT></A>,
you can use <A HREF="node229.html#PackedPrimitiveArray"><TT>PackedPrimitiveArray</TT></A> as a packed alternative
to <A HREF="node230.html#PrimitiveArray"><TT>PrimitiveArray</TT></A>, which is then compatible with the
corresponding C-arrays (see Table&nbsp;<A HREF="node10.html#tab:compatc">1</A>).

<P>
The type <A HREF="node249.html#Stream"><TT>Stream</TT></A>&nbsp;<TT>T</TT>,
of category&nbsp;<A HREF="node205.html#LinearStructureType"><TT>LinearStructureType</TT></A>&nbsp;<TT>T</TT>,
provides infinite linear structures.
There are several ways to create streams, the easier ones being via an
unbounded iterator, or via a function that computes its <!-- MATH
 ${n}^{{\rm th}}$
 -->
<IMG
 WIDTH="27" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.png"
 ALT="${n}^{{\rm th}}$"> element.
For example,
<PRE>
    import from MachineInteger, Stream MachineInteger;
    sqr1 := [n^2 for n in 0..];
    sqr2 := stream(0, (n:MachineInteger):MachineInteger +-&gt; n^2);
</PRE>

are two different ways to create the infinite stream <!-- MATH
 $[0^2, 1^2, 2^2, \dots]$
 -->
<IMG
 WIDTH="98" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.png"
 ALT="$[0^2, 1^2, 2^2, \dots]$">.
Streams can be iterated, yielding loops whose duration cannot be predicted
in advance, so using a parallel finite iterator or a termination condition
inside the loop is advisable. Finally, streams are lazy in that <IMG
 WIDTH="81" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.png"
 ALT="$s.0,\dots,s.n$">
are computed only when <IMG
 WIDTH="26" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$s.n$"> has been specifically resquested, and elements
are never recomputed a second time.

<P>
<TT>libaldor</TT>&nbsp;also provides different table stuctures:
hash tables are provided by the <A HREF="node196.html#HashTable"><TT>HashTable</TT></A> type and are created
via the <A HREF="node277.html#TableType:table"><TT>table</TT></A> function, as in
<BR>
<DIV ALIGN="CENTER">
<TT>t:HashTable(String, MachineInteger) := table();</TT></DIV>
The hash function defaults to the one provided by the type of the keys
if it has <A HREF="node203.html#HashType"><TT>HashType</TT></A>, but can be overridden by providing your
own as last argument to the hash table type constructor, as in
<BR>
<DIV ALIGN="CENTER">
<TT>t:HashTable(SingleFloat, MachineInteger, h) := table();</TT></DIV>
where <TT>h</TT> any function producing machine integers from machine
floats. Providing the hash function is required when the type of
the keys does not have <A HREF="node203.html#HashType"><TT>HashType</TT></A>. Sorted tables
are provided by the <A HREF="node246.html#SortedAssociationSet"><TT>SortedAssociationSet</TT></A> type,
those do not use hashing however.
Hash tables can also be used to make a function
<A HREF="node197.html#HashTable:remember"><TT>remember</TT></A> its previous
computed values: if <IMG
 WIDTH="77" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$f: A \to B$"> is any function, then
<DIV ALIGN="CENTER">
<TT>g:HashTable(A, B) := remember&nbsp;f;</TT></DIV>
creates a table <TT>g</TT> that can be used everywhere instead of <TT>g</TT>.
While <TT>f(a)</TT> always recomputes <IMG
 WIDTH="35" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.png"
 ALT="$f(a)$">, <TT>g(a)</TT> computes <IMG
 WIDTH="35" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.png"
 ALT="$f(a)$">
only once and stores the pair <IMG
 WIDTH="59" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$[a,f(a)]$"> in the table.

<P>
Finally, <TT>libaldor</TT>  also provides more specialized data structures
documented in the reference section: <A HREF="node241.html#Set"><TT>Set</TT></A>, <A HREF="node248.html#SortedSet"><TT>SortedSet</TT></A>,
<A HREF="node247.html#SortedList"><TT>SortedList</TT></A> and <A HREF="node239.html#Queue"><TT>Queue</TT></A>.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html548"
  HREF="node9.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html542"
  HREF="node6.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html536"
  HREF="node7.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html544"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html546"
  HREF="node315.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html549"
  HREF="node9.html">Input/Output</A>
<B> Up:</B> <A NAME="tex2html543"
  HREF="node6.html">User Guide</A>
<B> Previous:</B> <A NAME="tex2html537"
  HREF="node7.html">Arithmetic</A>
 &nbsp; <B>  <A NAME="tex2html545"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A NAME="tex2html547"
  HREF="node315.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Manuel Bronstein
2004-06-28
</ADDRESS>
</BODY>
</HTML>
