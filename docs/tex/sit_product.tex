\thistype{Product}
\History{Manuel Bronstein}{6/6/95}{created}
\Usage{import from \this~R}
\Params{ {\em R} & \altype{CommutativeRing} & A commutative ring\\ }
\Descr{\this~R provides finite products of elements of R,~\ie elements
of the type $\prod_{i=1}^n r_i^{e_i}$ where the $r_i$'s are in R and the
$e_i$'s are integers.}
\begin{exports}
\category{\altype{CopyableType}}\\
\category{\altype{Monoid}}\\
\alalias{\this}{size}{\#}:
& \% $\to$ \altype{MachineInteger} & Number of terms\\
\alexp{divisors}:
& \% $\to$ \altype{Generator} R & Iterate through all the divisors\\
\alexp{expand}: & \% $\to$ R & Multiply-out a product\\
\alexp{expandFraction}: & \% $\to$ (R, R) & Multiply-out a product\\
\alexp{generator}:
& \% $\to$ \altype{Generator} \builtin{Cross}(R, \altype{Integer}) &
Make an iterator\\
\alexp{log}: & (M:\altype{AbelianMonoid}, R $\to$ M) $\to$ (\% $\to$ M) &
Lift a logarithm\\
\alexp{term}: & (R, \altype{Integer}) $\to$ \% & Create a single term $r^e$\\
\alexp{times!}: & (\%, R, \altype{Integer}) $\to$ \% & In-place multiplication\\
\end{exports}
\alpage{size}
\Usage{\#~p}
\Signatures{ \#: & \% $\to$ \altype{MachineInteger}\\ }
\Params{ {\em p} & \% & A product\\ }
\Retval{Returns the number of terms in the product p.}
\alpage{divisors}
\Usage{ for d in \name~p repeat \{ \dots \} }
\Signature{\%}{\altype{Generator} R}
\Params{ {\em p} & \% & A product\\ }
\Descr{This generator yields all the products of the form
$\prod_{i=1}^n r_i^{f_i}$ where $p = \prod_{i=1}^n r_i^{e_i}$
and $0 \le f_i \le e_i$.}
\begin{asex}
\begin{ttyout}
import from Integer, Product Integer, List Integer;

p := term(3, 1) * term(2, 2) * term(5, 2)       -- p = 3^1 2^2 5^2 = 300
l := sort! [divisors p];
\end{ttyout}
creates the list
\begin{asoutput}
\> [1,2,3,4,5,6,10,12,15,20,25,30,50,60,75,100,150,300]\\
\end{asoutput}
of all the divisors of $300$.
\end{asex}
\alpage{expand}
\Usage{\name~p}
\Signature{\%}{R}
\Params{ {\em p} & \% & A product\\ }
\Retval{Returns the product of all the terms in p.}
\Remarks{When R is not a field, \name(p) only works when p has only
nonnegative exponents. Use \alexp{expandFraction} when p can have
negative exponents and R is not a field.}
\alpage{expandFraction}
\Usage{\name~p}
\Signature{\%}{(R, R)}
\Params{ {\em p} & \% & A product\\ }
\Retval{Returns $(n, d)$ where \emph{n} is the product of all the terms in
\emph{p} having positive exponents and \emph{d} is the product of all terms in
\emph{p} having negative exponents.}
\alseealso{\alexp{expand}}
\alpage{generator}
\Usage{
for term in p repeat \{ (c, n) := term; \dots \}\\
for term in \name~p repeat \{ (c, n) := term; \dots \}
}
\Signature{\%}{\altype{Generator} \builtin{Cross}(R, \altype{Integer})}
\Params{ {\em p} & \% & A product\\ }
\Descr{This function allows a product to be iterated independently of its
representation. The generator yields pairs of the form $(a, n)$ where
$a^n$ is a term in $p$.}
\begin{asex}
\begin{ttyout}
import from Integer, Product Integer;

p := term(3, 1) * term(2, 11) * term(5, 2)       -- p = 3^1 2^11 5^2
for term in p repeat { (c, n) := term; stdout << c << "," << n << newline; }
\end{ttyout}
writes
\begin{asoutput}
\> 3,1\\
\> 2,11\\
\> 5,2
\end{asoutput}
to the standard stream \alfunc{TextWriter}{stdout}.
\end{asex}
\alpage{log}
\Usage{\name(M,f)\\ \name(M,f)(p)}
\Signature{(M:\altype{AbelianMonoid}, R $\to$ M)}{\% $\to$ M}
\Params{
{\em M} & \altype{AbelianMonoid} & the image monoid\\
{\em f} & R $\to$ M & a logarithmic function on R\\
{\em p} & \% & A product\\
}
\Descr{\name(M,f)(p) returns $\sum_n n f(a_n)$ where
$p = \prod_n a_n^n$, while \name(M,f) returns the map
$\prod_n a_n^n \to \sum_n n f(a_n)$.}
\alpage{term}
\Usage{\name(r, n)}
\Signature{(R, \altype{Integer})}{\%}
\Params{
{\em r} & R & A ring element\\
{\em n} & \altype{Integer} & An exponent\\
}
\Retval{Returns $r^e$ as a product.}
\alpage{times!}
\Usage{\name(p, r, n)}
\Signature{(\%, R, \altype{Integer})}{\%}
\Params{
{\em p} & \% & A product\\
{\em r} & R & A ring element\\
{\em n} & \altype{Integer} & An exponent\\
}
\Retval{Returns $p\; r^e$ as a product, where the storage used by p is allowed
to be destroyed or reused, so p is lost after this call.}
\Remarks{The storage used by p is allowed to be destroyed or reused, so p
is lost after this call. This may cause p to be destroyed, so do not use
this unless p has been locally allocated, and is thus guaranteed not
to share space with other polynomials. Some functions are not necessarily
copying their arguments and can thus create memory aliases.}
