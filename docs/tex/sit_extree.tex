\thistype{ExpressionTree}
\History{Manuel Bronstein}{24/11/94}{created}
\History{Manuel Bronstein}{23/6/2003}{added infix}
\Usage{import from \this}
\Descr{\this~is a type whose elements are expression trees.}
\begin{exports}
\category{\altype{OutputType}}\\
\category{\altype{PrimitiveType}}\\
\alexp{aldor}: & (TEXT, \%) $\to$ TEXT & Conversion to \asharp code\\
\alexp{apply}:
& (OP, \altype{List} \%) $\to$ \% & Apply an operator to arguments\\
\alexp{apply}:
& (OP, \builtin{Tuple} \%) $\to$ \% & Apply an operator to arguments\\
\alexp{arguments}:
& \% $\to$ \altype{List} \% & Take the arguments of the root\\
\alexp{axiom}: & (TEXT, \%) $\to$ TEXT & Conversion to Axiom code\\
\alexp{C}: & (TEXT, \%) $\to$ TEXT & Conversion to C code\\
\alexp{extree}: & \altype{ExpressionTreeLeaf} $\to$ \% & Conversion to a tree\\
\alexp{fortran}: & TEXT, \%) $\to$ TEXT & Conversion to FORTRAN code\\
\alexp{infix}: & (TEXT, \%) $\to$ TEXT & Conversion to one-dim infix output\\
\alexp{is?}: & (\%, OP) $\to$ \altype{Boolean} & Test for a specific operator\\
\alexp{leaf}: & \% $\to$ \altype{ExpressionTreeLeaf} & Conversion to a leaf\\
\alexp{leaf?}: & \% $\to$ \altype{Boolean} & Test whether tree is a leaf\\
\alexp{lisp}: & TEXT, \%) $\to$ TEXT & Conversion to Lisp code\\
\alexp{maple}: & (TEXT, \%) $\to$ TEXT & Conversion to Maple code\\
\alexp{operator}: & \% $\to$ OP & Take the root operator\\
\alexp{tex}: & (TEXT, \%) $\to$ TEXT & Conversion to \LaTeX\\
\alexp{texParen?}:
& (\altype{MachineInteger}, \%) $\to$ \altype{Boolean} &
Check whether to parenthetize\\
\end{exports}
\begin{alwhere}
TEXT &==& \altype{TextWriter}\\
OP &==& \altype{ExpressionTreeOperator}\\
\end{alwhere}
\alpage{aldor,axiom,C,fortran,infix,lisp,maple,tex}
\altarget{aldor}
\altarget{axiom}
\altarget{C}
\altarget{fortran}
\altarget{infix}
\altarget{lisp}
\altarget{maple}
\altarget{tex}
\Usage{{\em format}(p, t)}
\Signature{(\altype{TextWriter}, \%)}{\altype{TextWriter}}
\Params{
{\em p} & \altype{TextWriter} & The port to write to\\
{\em t} & \% & An expression tree\\
}
\Descr{Writes to $p$ the expression corresponding to the tree $t$
in the requested format.}
\alpage{apply}
\Usage{
% \name(op, $t_1,\dots,t_n$)\\  % compiler bug
\name(op, [$t_1,\dots,t_n$])\\
% op($t_1,\dots,t_n$)\\         % compiler bug
op~[$t_1,\dots,t_n$]
}
\Signature{(\altype{ExpressionTreeOperator}, \altype{List} \%)}{\%}
% Compiler bug
% \Signatures{
% \name: & (\altype{ExpressionTreeOperator}, \altype{List} \%) $\to$ \%\\
% \name: & (\altype{ExpressionTreeOperator}, \builtin{Tuple} \%) $\to$ \%\\
% }
\Params{
{\em op} & \altype{ExpressionTreeOperator} & An operator\\
{\em $t_i$} & \% & Expression trees\\
}
\Retval{Returns the tree whose root is $op$, with arguments $t_1,\dots,t_n$.}
\alpage{arguments}
\Usage{\name~t}
\Signature{\%}{\altype{List} \%}
\Params{ {\em t} & \% & An expression tree\\ }
\Retval{Returns the list of arguments of the root operator of $t$, which must
not be a leaf.}
\alseealso{\alexp{operator}}
\alpage{extree}
\Usage{\name~a}
\Signature{\altype{ExpressionTreeLeaf}}{\%}
\Params{ {\em a} & \altype{ExpressionTreeLeaf} & A leaf\\ }
\Retval{\name~a returns $a$ as an expression tree.}
\alpage{is?}
\Usage{\name(t, op)}
\Signature{(\%, \altype{ExpressionTreeOperator})}{\altype{Boolean}}
\Params{
{\em t} & \% & An expression tree\\
{\em op} & \altype{ExpressionTreeOperator} & An operator\\
}
\Retval{\name(t, op) returns \true~if t is of the form op(args),
\false~otherwise.}
\alpage{leaf}
\altarget{\name?}
\Usage{ \name~t\\ \name?~t }
\Signatures{
\name: & \% $\to$ \altype{ExpressionTreeLeaf}\\
\name?: & \% $\to$ \altype{Boolean}\\
}
\Params{ {\em t} & \% & An expression tree\\ }
\Retval{
\name~a returns $a$ as a leaf is $a$ is a leaf.
\name?~a returns \true~if a is a leaf, \false~otherwise.
}
\alpage{negate}
\Usage{\name~t}
\Signature{\%}{\%}
\Params{ {\em t} & \% & An expression tree\\ }
\Retval{Returns the leaf $-t$ if $t$ is a numerical leaf with $t < 0$,
and returns $s$ if $t$ is of the form $(- s)$ for some tree $s$.
$t$ must be of one of the above 2 forms.}
\alseealso{\alexp{negative?}}
\alpage{negative?}
\Usage{\name~t}
\Signature{\%}{\altype{Boolean}}
\Params{ {\em t} & \% & An expression tree\\ }
\Retval{Returns \true~if either $t$ is a numerical leaf and $t < 0$,
or if $t$ is of the form $(- s)$ for some tree $s$, \false~otherwise.}
\alseealso{\alexp{negate}}
\alpage{operator}
\Usage{\name~t}
\Signature{\%}{\altype{ExpressionTreeOperator}}
\Params{ {\em t} & \% & An expression tree\\ }
\Retval{Returns the root operator of $t$, which must not be a leaf.}
\alseealso{\alexp{arguments}}
\alpage{texParen?}
\Usage{\name(prec, t)}
\Signature{(\altype{MachineInteger}, \%)}{\altype{Boolean}}
\Params{
{\em prec} & \altype{MachineInteger} & An operator precendence.\\
{\em t} & \% & An expression tree\\
}
\Retval{Returns \true~if $t$ should be parenthetized when appearing as
argument of an operator of precedence {\em prec}, \false~otherwise.}
